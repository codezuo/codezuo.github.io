{"meta":{"title":"Mr.J","subtitle":null,"description":null,"author":"Mr.J","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"向上转型和向下转型-2019-8-26","date":"2019-08-26T02:45:25.294Z","updated":"2019-08-26T04:33:42.561Z","comments":true,"path":"2019/08/26/向上转型和向下转型-2019-8-26/","link":"","permalink":"http://yoursite.com/2019/08/26/向上转型和向下转型-2019-8-26/","excerpt":"","text":"向上转型和向下转型向上转型1. 什么是向上转型？ 子类引用的对象转换为父类类型称为向上转型。通俗地说就是是将子类对象转为父类对象。此处父类对象可以是接口 2. 向上转型的优点和缺点优点：使代码变得简洁，提到了代码的可扩展性，体现了JAVA的抽象编程思想缺点：子类中新定义的成员方法会丢失，即子类特有的方法会失效 3. 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package String; class Animal &#123; // 创建父类 public void eat() &#123; // 父类成员方法 System.out.println(&quot;父类eating。。。&quot;); &#125; &#125; class bird extends Animal&#123; // 子类bird继承父类Animal @Override public void eat() &#123; // 子类重写父类eat方法 System.out.println(&quot;子类bird重写父类eat方法。。。&quot;); &#125; public void fly()&#123; // 子类特有的fly方法 System.out.println(&quot;子类bird调用特有的flying。。。&quot;); &#125; &#125; class Human&#123; // 父类human public void sleep() // 父类方法 &#123; System.out.println(&quot;父类人类 sleep..&quot;); &#125; &#125;class Male extends Human // 子类man继承父类human&#123; @Override public void sleep() // 重写父类方法 &#123; System.out.println(&quot;男人 sleep..&quot;); &#125;&#125;class Female extends Human &#123; // 子类Female继承父类human @Override public void sleep() &#123; // 重写父类方法 System.out.println(&quot;女人 sleep..&quot;); &#125;&#125;public class Sys&#123; public static void main(String[] args) &#123; Animal a = new bird(); // 子类bird向上转型到父类Animal -- 向上转型 a.eat(); // 只能调用子类重写父类的方法，输出: 子类bird重写父类eat方法。。。 // a.fly(); // 没有该方法，a虽指向子类对象，但此时子类作为向上转型的代价丢失和父类不同的fly()方法------ sleep(new Male()); //调用方法时传入的参数是子类 sleep(new Female()); &#125; public static void sleep(Human h) //方法传入的参数是父类------！！！ &#123; h.sleep(); &#125;&#125; 输出结果: 12345//子类重写父类的eat方法子类bird重写父类eat方法。。。 男人 sleep.. 女人 sleep.. 4. 详解: 向上转型的实现 123Animal a = new bird(); // 子类bird向上转型到父类Animal -- 向上转型a.eat(); // 只能调用子类重写父类的方法// a.fly(); // 此时子类作为向上转型的代价丢失和父类不同的fly()方法 为什么不直接创建bird对象，再调用bird的方法呢？ 1如果直接bird b = new bird();这样就没有体现出面向对象的抽象的编程思想呀，降低了代码的可扩展性. 向上转型的好处 1234567sleep(new Male()); //调用方法时传入的参数是子类sleep(new Female()); public static void sleep(Human h) //方法传入的参数是父类------！！！ &#123; h.sleep(); &#125;如上代码就是用的向上转型，若是不用向上转型，那么有多少个子类就得在这儿写多少种不同的睡觉方法~~~~~~ 向下转型1. 什么是向下转型？与向上转型相反，即是把父类对象转为子类对象。也就是说，在向下转型之前，它得先向上转型）或者用instanceof，这样才会正确。向下转型只能转型为本类对象（鱼是不能变成鸟的）。 2. 向下转型的优点和缺点优点：使得子类特有的方法也能调用，多用于java的泛型编程缺点：使用向下转型之前要先向上转型，否则容易报类型转换异常 3. 例子1234567891011121314151617181920212223242526package String;public class downcasting &#123; public static void main(String[] args) &#123; Girl g = new LittleGirl(); // 向下转型前要先向上转型 if (g instanceof LittleGirl)&#123; //instanceof用来判断父类对象是否为子类对象的实例 LittleGirl lg = (LittleGirl)g; // 向下转型 lg.cry(); //向下转型时调用的是子类的smile方法 lg.smile(); // 子类特有的方法也可以调用 &#125; &#125;&#125;class Girl&#123; public void smile()&#123; System.out.println(&quot;父类smile。。。&quot;); &#125;&#125;class LittleGirl extends Girl&#123; // 子类继承父类 @Override public void smile() &#123; // 重写父类smile方法 System.out.println(&quot;子类smile。。。&quot;); &#125; public void cry()&#123; System.out.println(&quot;子类特有的cry。。。&quot;); &#125;&#125; 输出结果： 12子类特有的cry。。。子类smile。。。 4. 详解: 向下转型的实现 123LittleGirl lg = (LittleGirl)g; // 向下转型,之前要先向上转型lg.cry(); //向下转型时调用的是子类的smile方法lg.smile(); // 子类特有的方法也可以调用 为什么不直接Girl g = new Girl(); 而是Girl g = new LittleGirl(); 1因为这样的话，向下转型是不安全的，编译无错但会运行会出错，会报类型转换异常 为什么用if (g instanceof LittleGirl); 1在转换前先判定父类是否是子类的实例对象，如果是才进行向下转换 向下转型的优点 1在泛型编程中得到极大的方便，详情请参考：https://blog.csdn.net/xyh269/article/details/52231944 总结 向上转型时，子类中新定义的成员方法会丢失。就像Animal访问不到fly的方法一样 子类引用不能指向父类对象。bird b = (bird)new Animal()这样是不行的。但是父类引用可以指向子类对象 向上转型的好处是减少重复代码，使代码变得简洁和提高系统扩展性，符合Java的面向对象的过程。 向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）或者用instanceof，这样才会正确 向下转型只能转型为本类对象（鱼是不能变成鸟的）。","categories":[],"tags":[]},{"title":"","slug":"包装类-2019-8-18","date":"2019-08-18T06:01:32.872Z","updated":"2019-08-19T03:20:26.921Z","comments":true,"path":"2019/08/18/包装类-2019-8-18/","link":"","permalink":"http://yoursite.com/2019/08/18/包装类-2019-8-18/","excerpt":"","text":"包装类1. 什么是包装类顾名思义就是将基本的数据类型以及一些辅助方法包装到类中2. 为什么需要包装类包装类型将基本类型的值包装在对象中,这样就可以使用对象的方法操作基本类型,类型之间的转换需要使用包装类型的方法才能完成3. 包装类与基本数据类型的区别友情提示:可以将包装类看做封装成对象的基本数据类型(即对象) a) 包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是 b) 包装类型是引用的传递，基本类型是值的传递 c) 声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间 d) 存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们 e) 初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null f) 使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 coolection Map时会使用 4. 包装类与基本数据类型之间的转换(jdk1.5之后可以自动转换)a) 装箱：基本类型-&gt;包装类1Integer i = 10; //自动将10(int)-&gt;10(Integer) b) 拆箱：包装类转-&gt;基本类型12Integer i = 10; //装箱int n = i; //拆箱,将Integer转换成int 5.相关问题 Integer型12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; //执行的操作是100先通过valueOf()方法进行装箱操作 Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); // true // 比较的是是否为同一个对象 System.out.println(i3==i4); // false // 比较的是两个值，而不是对象，所以为true System.out.println(i3.equals(i4); // true &#125;&#125; 原因: 先看Integer.valueOf源码123456public static Integer valueOf(int i) &#123; if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); &#125; IntegerCache实现的源码: 123456789101112131415161718192021222324252627private static class IntegerCache &#123; static final int high; static final Integer cache[]; static &#123; final int low = -128; // high value may be configured by property int h = 127; if (integerCacheHighPropValue != null) &#123; // Use Long.decode here to avoid invoking methods that // require Integer&apos;s autoboxing cache to be initialized int i = Long.decode(integerCacheHighPropValue).intValue(); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - -low); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125; 总结: Integer比较特殊,在-128到127之间,会走缓存,不在这个区间的数会走new Integer(i),也就是会创建新的对象,因此,100比较的时候是true,200比较的时候是false 2.Double型 1234567891011121314public class aaa &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1 == i2); // false System.out.println(i3 == i4); // false &#125;&#125; 原因: 在某个范围内的整型数值的个数是有限的，而浮点数却不是。double型不会走缓存，而是直接创建一个新的对象，因此都为false。 谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。1）第一种方式不会触发自动装箱的过程；而第二种方式会触发; 2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况(注意这并不是绝对的)。 参考博文:https://blog.csdn.net/li295214001/article/details/47020417","categories":[],"tags":[]},{"title":"","slug":"SSM整合","date":"2019-08-13T05:58:17.873Z","updated":"2019-08-13T06:16:44.620Z","comments":true,"path":"2019/08/13/SSM整合/","link":"","permalink":"http://yoursite.com/2019/08/13/SSM整合/","excerpt":"","text":"实现spring+springmvc+mybatis的整合1.这是我搭建的完整目录结构 2.具体代码2.1整合所需要引入的依赖有 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 1.日志 --&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2.数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DAO: MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3.Servlet web --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4.Spring --&gt; &lt;!-- 1)Spring核心：spring-core，spring-beans，spring-context spring-context-support ,spring-expression--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2)Spring DAO层 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3)Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4)Spring test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Map工具类 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt;2.2前端界面代码(很简单的)12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;account/findAll&quot;&gt;测试&lt;/a&gt;&lt;h1&gt;测试表单&lt;/h1&gt;&lt;form action=&quot;account/save&quot; method=&quot;post&quot;&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; 金额:&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 效果如下: 姓名: 金额: 2.3 domain(实体层)在pom.xml中引入lombok依赖，然后在实体类上添加@Data注解，可省略set/get方法和toString方法 123456789101112import lombok.Data;import java.io.Serializable;/** 实体类* */@Datapublic class Account implements Serializable &#123; private Integer id; private String name; private Double money;&#125; 2.4 controller(web层)这是前后端数据交互的层，主要用到springMvc框架技术 这里我只实现了插入数据和查询数据，修改数据和删除数据方法类似 123456789101112131415161718192021222324252627282930@Controller@RequestMapping(&quot;/account&quot;)public class AccountController &#123; @Autowired private AccountService accountService;/** 查询数据* */ @RequestMapping(&quot;/findAll&quot;) public String findAll(Model model)&#123; System.out.println(&quot;表现层：查询所有账户。。。&quot;); //调用service层的方法，完成整合springmvc List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(&quot;list&quot;,list); return &quot;list&quot;; &#125; /* * 插入数据 * */ @RequestMapping(&quot;/save&quot;) public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; System.out.println(&quot;表现层：插入信息到账户。。。&quot;); //调用service层的方法，完成整合springmvc accountService.saveAccount(account); response.sendRedirect(request.getContextPath()+&quot;/account/findAll&quot;); return; &#125;&#125; 2.5 dao层(也就是mapper层)这里是实现后端与数据库连接的方法，主要运用到mybatis框架知识 可以使用注解的方式写SQL代码(查询语句简单,且量少)，也可以在.xml文件中写SQL代码(推荐) 123456789101112131415/** Mybatis框架* */@Repositorypublic interface AccountDao &#123; /*查询账户的所有信息有*/ //@Select(&quot;select * from account&quot;) public List&lt;Account&gt; findAll(); /*保存账户信息*/ //通过注解形式查询 // @Insert(&quot;insert into account (name,money) values(#&#123;name&#125;,#&#123;money&#125;)&quot;) public void saveAccount(Account account);&#125; 2.5.1 在.xml文件中编写SQL代码1.以下是sql代码的.xml文件的位置注:SQL代码的.xml文件名要与dao中对应的类名一致,如：上述dao层是AccountDao,则要以AccountDao.xml命名 2.6 service层(springMVC框架技术)1. 如下图接口部分编写方法，实现接口的类主要调用接口的方法，通过这样降低代码之间的耦合度，便于增加或减少方法 2.AccountService代码如下1234567public interface AccountService &#123; /*查询账户的所有信息有*/ public List&lt;Account&gt; findAll(); /*保存账户信息*/ public void saveAccount(Account account);&#125; 3.AccountServiceImpl代码如下1234567891011121314151617@Service(&quot;accountService&quot;)//将该类交给springIOC容器保管public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(&quot;(service)业务层：查询所有账户信息。。。&quot;); return accountDao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; System.out.println(&quot;(service)业务层：保存账户信息。。。&quot;); accountDao.saveAccount(account); &#125;&#125; 2.7 application.xml中的配置如下注：该文件内主要写spring相关配置以及spring整合mybatis的相关配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- spring就会去自动扫描base-package对应的路径或者该路径的子包下面的java文件， 如果扫描到文件中带有@Service,@Component,@Repository,@Controller等这些注解的类， 则把这些类注册为bean --&gt; &lt;context:component-scan base-package=&quot;com.jgsu&quot;&gt; &lt;!--配置哪些注解不扫描--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--spring整合mybatis框架--&gt; &lt;!-- .配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt; &lt;!--1.配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driver&#125;&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;url&#125;&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt; &lt;/bean&gt; &lt;!--2.配置sqlSession工厂--&gt; &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sessionFactory&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:SqlMapConfig.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot;/&gt; &lt;!--将mapper文件中的(所有.xml文件)AccountDao.xml映射进去--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!--3.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中--&gt; &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--给出需要扫描Dao包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.jgsu.dao&quot;/&gt; &lt;!--注入SqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!--4.配置spring声明式事务管理器--&gt; &lt;!--配置事务管理器--&gt; &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; id=&quot;transactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--find方法打头的表示只读--&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置AOP增强--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.jgsu.service.impl.*ServiceImpl.*(..))&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.7 log4j.properties注:配置日志文件，便于打印日志 123456789101112131415161718log4j.rootLogger=INFO,Console,File #定义日志输出目的地为控制台log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录log4j.appender.File.File = logs/ssm.log #定义文件最大大小log4j.appender.File.MaxFileSize = 10MB # 输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125;][%c]%m%n 2.8 config.properties连接数据库的基本信息 12345//config.properties中创建数据库连接路线driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/ssmusername=rootpassword=xxxx 2.9 springmvc.xml编写springmvc相关配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt; &lt;!--1.开启注解扫描，只扫描Controller注解--&gt; &lt;context:component-scan base-package=&quot;com.jgsu&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--2.配置视图解析器对象--&gt; &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--3.过滤静态资源--&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt; &lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot;/&gt; &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;!--4.开启springmvc注解支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 源码地址:https://github.com/zuojunZzz/ssm ======================== 座右铭:日积月累才能拥有真本领，多思考，多实践作者:zuojunZzz","categories":[],"tags":[]}]}