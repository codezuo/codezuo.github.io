{"meta":{"title":"Mr.J","subtitle":null,"description":null,"author":"Mr.J","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"泛型-2019-08-29","date":"2019-08-29T09:04:48.357Z","updated":"2019-09-03T13:14:46.314Z","comments":true,"path":"2019/08/29/泛型-2019-08-29/","link":"","permalink":"http://yoursite.com/2019/08/29/泛型-2019-08-29/","excerpt":"","text":"泛型什么是泛型泛型，即参数化类型，顾名思义就是将原来具体的类型转化为类似于方法的变量参数，然后在调用时传入具体的参数。比如： 1List&lt;String&gt; list=new ArrayList&lt;&gt;(); ArrayList就是个泛型类，我们通过设定不同的类型，可以往集合里面存储不同类型的数据类型（而且只能存储设定的数据类型，这是泛型的优势之一） 使用泛型的好处 使用泛型之前我们一般是使用强制类型转换达到一种类型转换为另一种数据类型，但是如果不能强制类型转换的在编译时不会出错，到运行期在会出错，而泛型的引入使得原本不能强制转换的类型在编译器即可报错，这样大大节省了时间。它解决了向下转型时出现类型转换异常的问题。 泛型的引入使得我们可以对同一套代码引入多种数据类型 泛型类泛型类就是写类的时候使用泛型的形式，语法如下: 12类名&lt;T&gt; // T代表一个类型的名称当需添加多个参数时为，类名&lt;K,V&gt; 例子： 12345678910111213141516171819class demo&lt;T&gt;&#123; private T name; private T msg; public T getName() &#123; return name; &#125; public void setName(T name) &#123; this.name = name; &#125; public T getMsg() &#123; return msg; &#125; public void setMsg(T msg) &#123; this.msg = msg; &#125; 泛型方法泛型方法既可以存在于泛型类中也可以存在于普通类中。当我们能用泛型方法解决问题时尽量用泛型方法解决。例子： 123public &lt;E&gt; void laugh(E e)&#123; // （E e）表示传值类型任意，可为String类型也可为int型或者其他 System.out.println(&quot;使用的泛型方法&quot;+e); &#125; 泛型方法的基本特征 public与返回值中间非常重要，可以理解为声明此方法为泛型方法。 只有声明了的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 泛型接口知道怎么写接口就知道怎么写泛型接口 1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 注: 该泛型接口的实现类的所有地方都应该替换成所要传入的参数类型，如： 123456class DataHolder implements Generator&lt;String&gt;&#123; @Override public String next() &#123; return null; &#125;&#125; 泛型进阶篇1. 泛型的类型擦除机制了解类型擦除机制前先看个例子: 12345Class&lt;?&gt; class1=new ArrayList&lt;String&gt;().getClass();Class&lt;?&gt; class2=new ArrayList&lt;Integer&gt;().getClass();System.out.println(class1); //class java.util.ArrayListSystem.out.println(class2); //class java.util.ArrayListSystem.out.println(class1.equals(class2)); //true 对，这就是类型擦除机制，当我们同一个ArrayList类型中传入两个不同参数类型，运行后两者相等，这是因为在编译时编译器移除了两者的参数类型使得两个都为ArrayList类型，这就是类型擦除机制。 2. 限制泛型可用类型语法: 1class 类名&lt;T extends anyClass&gt; // anyClass 为某个接口或类 使用泛型限制后，泛型类的类型必须实现或继承 anyClass这个接口或类，但进行泛型限制时必须使用extends关键字。例如: 123456789public class LimitClass&lt;T extends List&gt;&#123; // 限制泛型的类型，只能实现List类中的类型 public static void main(String[] args) &#123; // 可以实例化已经实现List接口的类 LimitClass&lt;ArrayList&gt; a = new LimitClass&lt;&gt;(); // ArrayList LimitClass&lt;LinkedList&gt; b = new LimitClass&lt;&gt;(); // LinkedList // LimitClass&lt;String&gt; c = new LimitClass&lt;String&gt;(); // String 没有实现List()接口，所以编译期会报错 // LimitClass&lt;HashMap&gt; d = new LimitClass&lt;HashMap&gt;(); // HashMap没有实现List()接口，所以编译期会报错 &#125;&#125; 3. 使用类型通配符语法: 12泛型名&lt;? extends List&gt; // 上界通配符泛型名&lt;? super List&gt; // 下界通配符 上界通配符例子:12345678Box&lt;? extends Fruit&gt; box = new Box&lt;Orange&gt;(new Orange);//不能存入任何元素box.set(new Fruit); //illegalbox.set(new Orange);//illegal//取出来的东西只能存放在Fruit或它的基类Fruit fruit = box.get();Object fruit1 = box.get();Orange fruit2 = box.get(); //illegal 上面的注释已经很清楚了， 往 Box 里放东西的 set() 方法失效， 但是 get() 方法有效。上界只能外围取，不能往里放 下界通配符因为下界规定元素的最小的粒度，实际上是容器的元素的类型控制。所以放比 Fruit 粒度小的如 Orange、Apple 都行， 但往外取时， 只有所有类的基类Object对象才能装下。但是这样的话，元素的类型信息就全部消失了。PECS 原则 如果要从集合中读取类型T的数据， 并且不能写入，可以使用 上界通配符（&lt;？extends&gt;）—Producer Extends。 如果要从集合中写入类型T 的数据， 并且不需要读取，可以使用下界通配符（&lt;? super&gt;）—Consumer Super。 如果既要存又要取， 那么就要使用任何通配符。 注: 对于泛型的类型擦除机制，限制泛型可用类型，使用类型通配符属于泛型的高级用法，这里我这里暂时了解下就行，有兴趣的可自己百度。详情可参考:深入理解Java泛型","categories":[],"tags":[]},{"title":"","slug":"枚举类型-2019-29","date":"2019-08-29T03:31:45.115Z","updated":"2019-08-29T09:03:53.010Z","comments":true,"path":"2019/08/29/枚举类型-2019-29/","link":"","permalink":"http://yoursite.com/2019/08/29/枚举类型-2019-29/","excerpt":"","text":"枚举类型1. 什么是枚举类型它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。 2. 优势枚举类型声明提供了一种用户友好的变量定义方法，枚举数据类型所有可能出现的值，它具有以下特点 类型安全 紧凑有效的数据定义 可以和其他程序完美交互 运行效率高 3. 为什么要引入枚举 不用枚举的话: 123456789// 也称int枚举模式(类型不安全)class FavouriteColor_class&#123; public static final int RED = 1; public static final int BLACK = 3; public static final int GREEN = 2; public static final int BLUE = 4; public static final int WHITE = 5; public static final int BROWN = 6;&#125; 使用枚举类型后 12345//枚举类型关键字:enum(类型安全)public enum FavouriteColor &#123; //枚举成员 RED,GREEN,BLACK,BLUE,WHITE,BROWN&#125; 两者比较，省略了大量的代码，以及使得结构更清晰，代码更易维护与扩展 例子 12345678910111213141516171819202122232425262728293031323334353637//未用枚举类型时设置的常量package Test_Enum;public interface NotEnum &#123; public static final int RED = 1; public static final int BLACK = 3; public static final int GREEN = 2; public static final int BLUE = 4; public static final int WHITE = 5; public static final int BROWN = 6;&#125;// 实现该接口并写写doit()方法，传参为int型public class testNotEnum implements NotEnum &#123; public static void doit(int i) &#123; switch (i) &#123; case NotEnum.BLACK: System.out.println(&quot;doit()的黑色&quot;); break; case NotEnum.BLUE: System.out.println(&quot;doit()的蓝色&quot;); break; case NotEnum.BROWN: System.out.println(&quot;doit()的棕色&quot;); break; case NotEnum.GREEN: System.out.println(&quot;doit()的绿色&quot;); break; case NotEnum.WHITE: System.out.println(&quot;doit()的白色&quot;); break; case NotEnum.RED: System.out.println(&quot;doit()的红色&quot;); break; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243// 使用枚举类型，并写doit2()方法，传参为该枚举类public enum WithEnum &#123; RED,BLACK,GREEN,BLUE,WHITE,BROWN; public static void doit2(WithEnum c) &#123; switch (c) &#123; case BLACK: System.out.println(&quot;doit2()的黑色&quot;); break; case BLUE: System.out.println(&quot;doit2()的蓝色&quot;); break; case BROWN: System.out.println(&quot;doit2()的棕色&quot;); break; case GREEN: System.out.println(&quot;doit2()的绿色&quot;); break; case WHITE: System.out.println(&quot;doit2()的白色&quot;); break; case RED: System.out.println(&quot;doit2()的红色&quot;); break; &#125; &#125;&#125;// 测试：public class test &#123; public static void main(String[] args) &#123; WithEnum.doit2(WithEnum.BLUE); testNotEnum.doit(testNotEnum.BLACK); WithEnum.doit2(WithEnum.RED); testNotEnum.doit(7); //传值为:7 不在范围内，不报错，但没有数据， //WithEnum.doit2(2); &#125;&#125;// 输出结果：doit2()的蓝色doit()的黑色doit2()的红色 原因:没用枚举时，方法的传参为int型，当传入的值不在该范围内但为int型时，编译及运行不会出错，但没有结果。而使用枚举类型时，传的参可以为该枚举类，所以当传入不存在的值时,编译就会报错。这样就使得类型安全了 4. 深入了解枚举类型 几种枚举类型常用方法 方法名称 具体含义 使用方法 values() 枚举成员以数组形式返回 枚举类型名称.values() valueOf() 将普通字符串转换为枚举实例 枚举类型名称.valueOf() compareTo() 比较两个枚举对象在定义时的顺序 枚举成员.compareTo() ordinal 用于得到枚举成员位置索引 枚举成员.ordinal() 1. values()方法12345678910111213141516171819public class testValues &#123; enum Color&#123; // 将常量放在枚举类型中 RED,BLACK,BLUE,YELLOW; &#125; // 循环由values()返回的数组 public static void main(String[] args) &#123; for (int i = 0; i &lt; Color.values().length; i++) &#123; // 将枚举成员变量打印 System.out.println(&quot;枚举类型成员变量: &quot;+Color.values()[i]); &#125; &#125;&#125;/* 输出结果：枚举类型成员变量: RED枚举类型成员变量: BLACK枚举类型成员变量: BLUE枚举类型成员变量: YELLOW*/ 2. valueOf()和compareTo()方法valueOf()和compareTo()方法一般一起用 1234567891011121314151617181920212223public class testValues &#123; enum Color&#123; // 将常量放在枚举类型中 RED,BLACK,BLUE,YELLOW; &#125; public static void compare(Color color)&#123; // 根据values()返回的数组做循环操作 for (int i = 0; i &lt; Color.values().length; i++) &#123; // 调用compareTo方法与某个数进行比较，返回结果为正值则表示在枚举对象之前，相同则为0，否则为负数 System.out.println(color + &quot;与&quot; + Color.values()[i] + &quot;的比较结果为:&quot; + color.compareTo(Color.values()[i])); &#125; &#125; public static void main(String[] args) &#123; compare(Color.valueOf(&quot;BLUE&quot;)); // 调用valueOf方法 &#125;&#125;/*输出结果:BLUE与RED的比较结果为:2BLUE与BLACK的比较结果为:1BLUE与BLUE的比较结果为:0BLUE与YELLOW的比较结果为:-1*/ 枚举类型中的构造方法 注： 枚举类型中可以添加构造方法，但该方法必须为private修饰,也可以实现接口中的方法。 123456789101112131415161718192021222324252627282930313233public class test_01 &#123; enum Food&#123; APPLE(&quot;苹果&quot;), BANANA(&quot;香蕉&quot;), ORANGE(&quot;橘子&quot;); private String description; // private变量description Food()&#123;&#125; Food(String description) &#123; // 创建description构造方法 this.description = description; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt;Food.values().length ; i++) &#123; System.out.println(Food.values()[i]+&quot;调用getDescription()方法为：&quot;+Food.values()[i].description); &#125; &#125;&#125;/* 输出结果：APPLE调用getDescription()方法为：苹果BANANA调用getDescription()方法为：香蕉ORANGE调用getDescription()方法为：橘子*/ 总结 枚举类型继承于Enum类，所以只能用实现接口，不能再继承其他类。 枚举类型会编译器处理成 抽象类（含抽象方法）或 final类。 枚举成员都是public static final 的枚举实例常量。枚举成员必须是最先声明,且只能声明一行（逗号隔开，分号结束）。 构造方法必须是 private，如果定义了有参的构造器，就要注意枚举成员的声明。没有定义构造方法时，编译器为枚举类自动添加的是一个带两个参数的构造方法,并不是无参构造器。 编译器会为枚举类添加 values() 和 valueOf()两个方法。 没有抽象方法的枚举类，被编译器处理成 final 类。如果是包含抽象方法的枚举类则被处理成抽象abstract类。 Enum实现了Serializable接口，并且几乎所有方法都是 final方法 参考文章 https://juejin.im/post/5ad970ccf265da0b7b357365#heading-8 https://blog.csdn.net/javazejian/article/details/71333103#%E6%9E%9A%E4%B8%BE%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95","categories":[],"tags":[]},{"title":"","slug":"向上转型和向下转型-2019-8-26","date":"2019-08-26T02:45:25.294Z","updated":"2019-08-26T04:33:42.561Z","comments":true,"path":"2019/08/26/向上转型和向下转型-2019-8-26/","link":"","permalink":"http://yoursite.com/2019/08/26/向上转型和向下转型-2019-8-26/","excerpt":"","text":"向上转型和向下转型向上转型1. 什么是向上转型？ 子类引用的对象转换为父类类型称为向上转型。通俗地说就是是将子类对象转为父类对象。此处父类对象可以是接口 2. 向上转型的优点和缺点优点：使代码变得简洁，提到了代码的可扩展性，体现了JAVA的抽象编程思想缺点：子类中新定义的成员方法会丢失，即子类特有的方法会失效 3. 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package String; class Animal &#123; // 创建父类 public void eat() &#123; // 父类成员方法 System.out.println(&quot;父类eating。。。&quot;); &#125; &#125; class bird extends Animal&#123; // 子类bird继承父类Animal @Override public void eat() &#123; // 子类重写父类eat方法 System.out.println(&quot;子类bird重写父类eat方法。。。&quot;); &#125; public void fly()&#123; // 子类特有的fly方法 System.out.println(&quot;子类bird调用特有的flying。。。&quot;); &#125; &#125; class Human&#123; // 父类human public void sleep() // 父类方法 &#123; System.out.println(&quot;父类人类 sleep..&quot;); &#125; &#125;class Male extends Human // 子类man继承父类human&#123; @Override public void sleep() // 重写父类方法 &#123; System.out.println(&quot;男人 sleep..&quot;); &#125;&#125;class Female extends Human &#123; // 子类Female继承父类human @Override public void sleep() &#123; // 重写父类方法 System.out.println(&quot;女人 sleep..&quot;); &#125;&#125;public class Sys&#123; public static void main(String[] args) &#123; Animal a = new bird(); // 子类bird向上转型到父类Animal -- 向上转型 a.eat(); // 只能调用子类重写父类的方法，输出: 子类bird重写父类eat方法。。。 // a.fly(); // 没有该方法，a虽指向子类对象，但此时子类作为向上转型的代价丢失和父类不同的fly()方法------ sleep(new Male()); //调用方法时传入的参数是子类 sleep(new Female()); &#125; public static void sleep(Human h) //方法传入的参数是父类------！！！ &#123; h.sleep(); &#125;&#125; 输出结果: 12345//子类重写父类的eat方法子类bird重写父类eat方法。。。 男人 sleep.. 女人 sleep.. 4. 详解: 向上转型的实现 123Animal a = new bird(); // 子类bird向上转型到父类Animal -- 向上转型a.eat(); // 只能调用子类重写父类的方法// a.fly(); // 此时子类作为向上转型的代价丢失和父类不同的fly()方法 为什么不直接创建bird对象，再调用bird的方法呢？ 1如果直接bird b = new bird();这样就没有体现出面向对象的抽象的编程思想呀，降低了代码的可扩展性. 向上转型的好处 1234567sleep(new Male()); //调用方法时传入的参数是子类sleep(new Female()); public static void sleep(Human h) //方法传入的参数是父类------！！！ &#123; h.sleep(); &#125;如上代码就是用的向上转型，若是不用向上转型，那么有多少个子类就得在这儿写多少种不同的睡觉方法~~~~~~ 向下转型1. 什么是向下转型？与向上转型相反，即是把父类对象转为子类对象。也就是说，在向下转型之前，它得先向上转型）或者用instanceof，这样才会正确。向下转型只能转型为本类对象（鱼是不能变成鸟的）。 2. 向下转型的优点和缺点优点：使得子类特有的方法也能调用，多用于java的泛型编程缺点：使用向下转型之前要先向上转型，否则容易报类型转换异常 3. 例子1234567891011121314151617181920212223242526package String;public class downcasting &#123; public static void main(String[] args) &#123; Girl g = new LittleGirl(); // 向下转型前要先向上转型 if (g instanceof LittleGirl)&#123; //instanceof用来判断父类对象是否为子类对象的实例 LittleGirl lg = (LittleGirl)g; // 向下转型 lg.cry(); //向下转型时调用的是子类的smile方法 lg.smile(); // 子类特有的方法也可以调用 &#125; &#125;&#125;class Girl&#123; public void smile()&#123; System.out.println(&quot;父类smile。。。&quot;); &#125;&#125;class LittleGirl extends Girl&#123; // 子类继承父类 @Override public void smile() &#123; // 重写父类smile方法 System.out.println(&quot;子类smile。。。&quot;); &#125; public void cry()&#123; System.out.println(&quot;子类特有的cry。。。&quot;); &#125;&#125; 输出结果： 12子类特有的cry。。。子类smile。。。 4. 详解: 向下转型的实现 123LittleGirl lg = (LittleGirl)g; // 向下转型,之前要先向上转型lg.cry(); //向下转型时调用的是子类的smile方法lg.smile(); // 子类特有的方法也可以调用 为什么不直接Girl g = new Girl(); 而是Girl g = new LittleGirl(); 1因为这样的话，向下转型是不安全的，编译无错但会运行会出错，会报类型转换异常 为什么用if (g instanceof LittleGirl); 1在转换前先判定父类是否是子类的实例对象，如果是才进行向下转换 向下转型的优点 1在泛型编程中得到极大的方便，详情请参考：https://blog.csdn.net/xyh269/article/details/52231944 总结 向上转型时，子类中新定义的成员方法会丢失。就像Animal访问不到fly的方法一样 子类引用不能指向父类对象。bird b = (bird)new Animal()这样是不行的。但是父类引用可以指向子类对象 向上转型的好处是减少重复代码，使代码变得简洁和提高系统扩展性，符合Java的面向对象的过程。 向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）或者用instanceof，这样才会正确 向下转型只能转型为本类对象（鱼是不能变成鸟的）。","categories":[],"tags":[]},{"title":"","slug":"包装类-2019-8-18","date":"2019-08-18T06:01:32.872Z","updated":"2019-08-19T03:20:26.921Z","comments":true,"path":"2019/08/18/包装类-2019-8-18/","link":"","permalink":"http://yoursite.com/2019/08/18/包装类-2019-8-18/","excerpt":"","text":"包装类1. 什么是包装类顾名思义就是将基本的数据类型以及一些辅助方法包装到类中2. 为什么需要包装类包装类型将基本类型的值包装在对象中,这样就可以使用对象的方法操作基本类型,类型之间的转换需要使用包装类型的方法才能完成3. 包装类与基本数据类型的区别友情提示:可以将包装类看做封装成对象的基本数据类型(即对象) a) 包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是 b) 包装类型是引用的传递，基本类型是值的传递 c) 声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间 d) 存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们 e) 初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null f) 使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 coolection Map时会使用 4. 包装类与基本数据类型之间的转换(jdk1.5之后可以自动转换)a) 装箱：基本类型-&gt;包装类1Integer i = 10; //自动将10(int)-&gt;10(Integer) b) 拆箱：包装类转-&gt;基本类型12Integer i = 10; //装箱int n = i; //拆箱,将Integer转换成int 5.相关问题 Integer型12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; //执行的操作是100先通过valueOf()方法进行装箱操作 Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); // true // 比较的是是否为同一个对象 System.out.println(i3==i4); // false // 比较的是两个值，而不是对象，所以为true System.out.println(i3.equals(i4); // true &#125;&#125; 原因: 先看Integer.valueOf源码123456public static Integer valueOf(int i) &#123; if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); &#125; IntegerCache实现的源码: 123456789101112131415161718192021222324252627private static class IntegerCache &#123; static final int high; static final Integer cache[]; static &#123; final int low = -128; // high value may be configured by property int h = 127; if (integerCacheHighPropValue != null) &#123; // Use Long.decode here to avoid invoking methods that // require Integer&apos;s autoboxing cache to be initialized int i = Long.decode(integerCacheHighPropValue).intValue(); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - -low); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125; 总结: Integer比较特殊,在-128到127之间,会走缓存,不在这个区间的数会走new Integer(i),也就是会创建新的对象,因此,100比较的时候是true,200比较的时候是false 2.Double型 1234567891011121314public class aaa &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1 == i2); // false System.out.println(i3 == i4); // false &#125;&#125; 原因: 在某个范围内的整型数值的个数是有限的，而浮点数却不是。double型不会走缓存，而是直接创建一个新的对象，因此都为false。 谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。1）第一种方式不会触发自动装箱的过程；而第二种方式会触发; 2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况(注意这并不是绝对的)。 参考博文:https://blog.csdn.net/li295214001/article/details/47020417","categories":[],"tags":[]},{"title":"","slug":"SSM整合","date":"2019-08-13T05:58:17.873Z","updated":"2019-08-13T06:16:44.620Z","comments":true,"path":"2019/08/13/SSM整合/","link":"","permalink":"http://yoursite.com/2019/08/13/SSM整合/","excerpt":"","text":"实现spring+springmvc+mybatis的整合1.这是我搭建的完整目录结构 2.具体代码2.1整合所需要引入的依赖有 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 1.日志 --&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2.数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DAO: MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3.Servlet web --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4.Spring --&gt; &lt;!-- 1)Spring核心：spring-core，spring-beans，spring-context spring-context-support ,spring-expression--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 2)Spring DAO层 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 3)Spring web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 4)Spring test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Map工具类 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;/dependency&gt;2.2前端界面代码(很简单的)12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;account/findAll&quot;&gt;测试&lt;/a&gt;&lt;h1&gt;测试表单&lt;/h1&gt;&lt;form action=&quot;account/save&quot; method=&quot;post&quot;&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; 金额:&lt;input type=&quot;text&quot; name=&quot;money&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;保存&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 效果如下: 姓名: 金额: 2.3 domain(实体层)在pom.xml中引入lombok依赖，然后在实体类上添加@Data注解，可省略set/get方法和toString方法 123456789101112import lombok.Data;import java.io.Serializable;/** 实体类* */@Datapublic class Account implements Serializable &#123; private Integer id; private String name; private Double money;&#125; 2.4 controller(web层)这是前后端数据交互的层，主要用到springMvc框架技术 这里我只实现了插入数据和查询数据，修改数据和删除数据方法类似 123456789101112131415161718192021222324252627282930@Controller@RequestMapping(&quot;/account&quot;)public class AccountController &#123; @Autowired private AccountService accountService;/** 查询数据* */ @RequestMapping(&quot;/findAll&quot;) public String findAll(Model model)&#123; System.out.println(&quot;表现层：查询所有账户。。。&quot;); //调用service层的方法，完成整合springmvc List&lt;Account&gt; list = accountService.findAll(); model.addAttribute(&quot;list&quot;,list); return &quot;list&quot;; &#125; /* * 插入数据 * */ @RequestMapping(&quot;/save&quot;) public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; System.out.println(&quot;表现层：插入信息到账户。。。&quot;); //调用service层的方法，完成整合springmvc accountService.saveAccount(account); response.sendRedirect(request.getContextPath()+&quot;/account/findAll&quot;); return; &#125;&#125; 2.5 dao层(也就是mapper层)这里是实现后端与数据库连接的方法，主要运用到mybatis框架知识 可以使用注解的方式写SQL代码(查询语句简单,且量少)，也可以在.xml文件中写SQL代码(推荐) 123456789101112131415/** Mybatis框架* */@Repositorypublic interface AccountDao &#123; /*查询账户的所有信息有*/ //@Select(&quot;select * from account&quot;) public List&lt;Account&gt; findAll(); /*保存账户信息*/ //通过注解形式查询 // @Insert(&quot;insert into account (name,money) values(#&#123;name&#125;,#&#123;money&#125;)&quot;) public void saveAccount(Account account);&#125; 2.5.1 在.xml文件中编写SQL代码1.以下是sql代码的.xml文件的位置注:SQL代码的.xml文件名要与dao中对应的类名一致,如：上述dao层是AccountDao,则要以AccountDao.xml命名 2.6 service层(springMVC框架技术)1. 如下图接口部分编写方法，实现接口的类主要调用接口的方法，通过这样降低代码之间的耦合度，便于增加或减少方法 2.AccountService代码如下1234567public interface AccountService &#123; /*查询账户的所有信息有*/ public List&lt;Account&gt; findAll(); /*保存账户信息*/ public void saveAccount(Account account);&#125; 3.AccountServiceImpl代码如下1234567891011121314151617@Service(&quot;accountService&quot;)//将该类交给springIOC容器保管public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(&quot;(service)业务层：查询所有账户信息。。。&quot;); return accountDao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; System.out.println(&quot;(service)业务层：保存账户信息。。。&quot;); accountDao.saveAccount(account); &#125;&#125; 2.7 application.xml中的配置如下注：该文件内主要写spring相关配置以及spring整合mybatis的相关配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- spring就会去自动扫描base-package对应的路径或者该路径的子包下面的java文件， 如果扫描到文件中带有@Service,@Component,@Repository,@Controller等这些注解的类， 则把这些类注册为bean --&gt; &lt;context:component-scan base-package=&quot;com.jgsu&quot;&gt; &lt;!--配置哪些注解不扫描--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--spring整合mybatis框架--&gt; &lt;!-- .配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&gt; &lt;!--1.配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driver&#125;&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;url&#125;&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt; &lt;/bean&gt; &lt;!--2.配置sqlSession工厂--&gt; &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sessionFactory&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:SqlMapConfig.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot;/&gt; &lt;!--将mapper文件中的(所有.xml文件)AccountDao.xml映射进去--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!--3.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中--&gt; &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--给出需要扫描Dao包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.jgsu.dao&quot;/&gt; &lt;!--注入SqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!--4.配置spring声明式事务管理器--&gt; &lt;!--配置事务管理器--&gt; &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; id=&quot;transactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--find方法打头的表示只读--&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置AOP增强--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.jgsu.service.impl.*ServiceImpl.*(..))&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 2.7 log4j.properties注:配置日志文件，便于打印日志 123456789101112131415161718log4j.rootLogger=INFO,Console,File #定义日志输出目的地为控制台log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录log4j.appender.File.File = logs/ssm.log #定义文件最大大小log4j.appender.File.MaxFileSize = 10MB # 输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125;][%c]%m%n 2.8 config.properties连接数据库的基本信息 12345//config.properties中创建数据库连接路线driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/ssmusername=rootpassword=xxxx 2.9 springmvc.xml编写springmvc相关配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt; &lt;!--1.开启注解扫描，只扫描Controller注解--&gt; &lt;context:component-scan base-package=&quot;com.jgsu&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--2.配置视图解析器对象--&gt; &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--3.过滤静态资源--&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt; &lt;mvc:resources mapping=&quot;/images/**&quot; location=&quot;/images/&quot;/&gt; &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;!--4.开启springmvc注解支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 源码地址:https://github.com/zuojunZzz/ssm ======================== 座右铭:日积月累才能拥有真本领，多思考，多实践作者:zuojunZzz","categories":[],"tags":[]}]}